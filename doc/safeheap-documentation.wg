WordGrinder dumpfile v3: this is a text file; diff me!
.addons.autosave.enabled: false
.addons.autosave.pattern: "%F.autosave.%T.wg"
.addons.autosave.period: 10
.addons.htmlexport.bold_off: "</b>"
.addons.htmlexport.bold_on: "<b>"
.addons.htmlexport.italic_off: "</i>"
.addons.htmlexport.italic_on: "<i>"
.addons.htmlexport.underline_off: "</u>"
.addons.htmlexport.underline_on: "<u>"
.addons.pagecount.enabled: false
.addons.pagecount.wordsperpage: 250
.addons.scrapbook.document: "Scrapbook"
.addons.scrapbook.pattern: "Item from '%N' at %T:"
.addons.scrapbook.timestamp: true
.addons.smartquotes.doublequotes: false
.addons.smartquotes.leftdouble: "“"
.addons.smartquotes.leftsingle: "‘"
.addons.smartquotes.notinraw: true
.addons.smartquotes.rightdouble: "”"
.addons.smartquotes.rightsingle: "’"
.addons.smartquotes.singlequotes: false
.addons.spellchecker.enabled: false
.addons.spellchecker.usesystemdictionary: true
.addons.spellchecker.useuserdictionary: true
.documents.1.co: 2
.documents.1.cp: 43
.documents.1.cw: 11
.documents.1.margin: 0
.documents.1.name: "main"
.documents.1.sticky_selection: false
.documents.1.viewmode: 1
.documents.1.wordcount: 492
.fileformat: 8
.menu.accelerators.BACKSPACE: "ZDPC"
.menu.accelerators.DELETE: "ZDNC"
.menu.accelerators.DOWN: "ZD"
.menu.accelerators.EC: "^C"
.menu.accelerators.ECadd: "^M"
.menu.accelerators.ECfind: "^L"
.menu.accelerators.EF: "^F"
.menu.accelerators.EG: "^G"
.menu.accelerators.EN: "^K"
.menu.accelerators.END: "ZE"
.menu.accelerators.EP: "^V"
.menu.accelerators.ER: "^R"
.menu.accelerators.ET: "^X"
.menu.accelerators.Eredo: "^Y"
.menu.accelerators.Eundo: "^Z"
.menu.accelerators.FQ: "^Q"
.menu.accelerators.FS: "^S"
.menu.accelerators.HOME: "ZH"
.menu.accelerators.LEFT: "ZL"
.menu.accelerators.PGDN: "ZPGDN"
.menu.accelerators.PGUP: "ZPGUP"
.menu.accelerators.RIGHT: "ZR"
.menu.accelerators.SB: "^B"
.menu.accelerators.SDOWN: "ZSD"
.menu.accelerators.SEND: "ZSE"
.menu.accelerators.SHOME: "ZSH"
.menu.accelerators.SI: "^I"
.menu.accelerators.SLEFT: "ZSL"
.menu.accelerators.SO: "^O"
.menu.accelerators.SP: "^P"
.menu.accelerators.SPGDN: "ZSPGDN"
.menu.accelerators.SPGUP: "ZSPGUP"
.menu.accelerators.SRIGHT: "ZSR"
.menu.accelerators.SU: "^U"
.menu.accelerators.SUP: "ZSU"
.menu.accelerators.S^DOWN: "ZSNP"
.menu.accelerators.S^LEFT: "ZSWL"
.menu.accelerators.S^PGDN: "ZSED"
.menu.accelerators.S^PGUP: "ZSBD"
.menu.accelerators.S^RIGHT: "ZSWR"
.menu.accelerators.S^UP: "ZSPP"
.menu.accelerators.UP: "ZU"
.menu.accelerators.ZBD: "^PGUP"
.menu.accelerators.ZD: "DOWN"
.menu.accelerators.ZDNC: "DELETE"
.menu.accelerators.ZDPC: "BACKSPACE"
.menu.accelerators.ZDW: "^E"
.menu.accelerators.ZE: "END"
.menu.accelerators.ZED: "^PGDN"
.menu.accelerators.ZH: "HOME"
.menu.accelerators.ZL: "LEFT"
.menu.accelerators.ZM: "^@"
.menu.accelerators.ZNP: "^DOWN"
.menu.accelerators.ZPGDN: "PGDN"
.menu.accelerators.ZPGUP: "PGUP"
.menu.accelerators.ZPP: "^UP"
.menu.accelerators.ZR: "RIGHT"
.menu.accelerators.ZSBD: "S^PGUP"
.menu.accelerators.ZSD: "SDOWN"
.menu.accelerators.ZSE: "SEND"
.menu.accelerators.ZSED: "S^PGDN"
.menu.accelerators.ZSH: "SHOME"
.menu.accelerators.ZSL: "SLEFT"
.menu.accelerators.ZSNP: "S^DOWN"
.menu.accelerators.ZSPGDN: "SPGDN"
.menu.accelerators.ZSPGUP: "SPGUP"
.menu.accelerators.ZSPP: "S^UP"
.menu.accelerators.ZSR: "SRIGHT"
.menu.accelerators.ZSU: "SUP"
.menu.accelerators.ZSW: "^W"
.menu.accelerators.ZSWL: "S^LEFT"
.menu.accelerators.ZSWR: "S^RIGHT"
.menu.accelerators.ZU: "UP"
.menu.accelerators.ZWL: "^LEFT"
.menu.accelerators.ZWR: "^RIGHT"
.menu.accelerators.^@: "ZM"
.menu.accelerators.^B: "SB"
.menu.accelerators.^C: "EC"
.menu.accelerators.^DOWN: "ZNP"
.menu.accelerators.^E: "ZDW"
.menu.accelerators.^F: "EF"
.menu.accelerators.^G: "EG"
.menu.accelerators.^I: "SI"
.menu.accelerators.^K: "EN"
.menu.accelerators.^L: "ECfind"
.menu.accelerators.^LEFT: "ZWL"
.menu.accelerators.^M: "ECadd"
.menu.accelerators.^O: "SO"
.menu.accelerators.^P: "SP"
.menu.accelerators.^PGDN: "ZED"
.menu.accelerators.^PGUP: "ZBD"
.menu.accelerators.^Q: "FQ"
.menu.accelerators.^R: "ER"
.menu.accelerators.^RIGHT: "ZWR"
.menu.accelerators.^S: "FS"
.menu.accelerators.^U: "SU"
.menu.accelerators.^UP: "ZPP"
.menu.accelerators.^V: "EP"
.menu.accelerators.^W: "ZSW"
.menu.accelerators.^X: "ET"
.menu.accelerators.^Y: "Eredo"
.menu.accelerators.^Z: "Eundo"
.name: "/Users/user/Desktop/safeheap/doc/doc.wg"
.statusbar: true
.current: 1
#1
H1 SafeHeap Library Documentation
H2 1. Project
L The project is maintained by Mikhailuwu (https://github.com/mikhailuwu) at https://github.com/mikhailuwu/safeheap.
L If you have any bugs or feature requests then please do create an issue at the project site.
H2 1.1 Purpose
L SafeHeap (safeheap.h) is a C/C++ library made primarily for Linux kernel systems, providing a framework of security implementations for the user developer to use for a more secure memory handling.
H2 Content
L 1. Project
L    1.1 Purpose
L 2. Protection
L    2.1 Segmentation
L    2.2 Cryptography
L        2.2.1 Key storage
L              2.2.1.1 TPM
L              2.2.1.2 Memory
L              2.2.1.3 Internet (experimental)
L        2.2.2 Algorithms
L    2.3 Randomization
L        2.3.1 Address Space Layout Randomization
L        2.3.2 Side-Channel Noise
L    2.4 Erasure
L        2.4.1 Volatile Memory Wiping
L        2.4.2 Hard Disk Memory Wiping
L 3. External
L    3.1 Functions
L        3.1.1 sh_malloc
L        3.1.2 sh_free
L        3.1.3 sh_read
L        3.1.4 sh_write
L    3.2 Types
L        3.2.1 shared_buffer
L 4. Internal
L     4.1 Types
L         4.1.1 sh_protected_memory_table_t
L         4.1.2 sh_protected_entry_t
L         4.1.3 sh_segment_descriptor_t
L         4.1.4 sh_protection_policy_t
L         4.1.5 sh_cipher_policy_t
L     4.2 Functions
H2 2. Protection
P For a dynamic variable to become protected, the user must first call the sh_malloc (external) function. This function will allocate heap memory either as a single block or in segments depending on user parameters. Thereafter an entry is created internally in the Protection Memory Table (PMT) with this information, including a protection grade passed by the user. The protection grade indicates what protection policy should be employed when handling the allocated memory, including encryption, segmentation, aslr, side-channel noise, and erasure. After the sh_malloc finishes, it returns an identifier pointer used to reference the protected memory through the sh_free, sh_read, and sh_write functions.
P To read the memory the user must call the sh_read function that internally transforms the protected memory into a single buffer which is then provided to the user as a pointer, whether the identifier pointer is changed or not depends on the memory address space layout just as with malloc family functions.
P To write to memory the user must first call the 
.
